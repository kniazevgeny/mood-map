<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Scrollable World • Ring-Segment Tides + Snap-to-Center</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --world-size: 4000px;
      --center-r: 80;              /* central circle radius (px) */
      --grid-step: 80px;

      --bg-1:#0b0f14; --fg:#eaf2ff; --muted:#8aa4c1;
      --center-stroke:#7fb3ff;     /* blue outlines */
      --tide:#23d4c0;              /* teal tides */
      --tide2:#22cbb8;             /* second teal (target) */

      --point:#1cc8b7;
      --point-active:#ff4d4f;
    }

    html,body{height:100%;margin:0;background:var(--bg-1);color:var(--fg);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

    .viewport{
      position:relative;height:100%;overflow:auto;overscroll-behavior:contain;cursor:grab;
      scroll-behavior:smooth;
      background:
        linear-gradient(90deg,#0b0f14 0,#0b0f14 calc(var(--grid-step) - 1px),#0b2135 calc(var(--grid-step) - 1px),#0b2135 var(--grid-step)),
        linear-gradient(180deg,#0b0f14 0,#0b0f14 calc(var(--grid-step) - 1px),#0b2135 calc(var(--grid-step) - 1px),#0b2135 var(--grid-step));
      background-size:var(--grid-step) var(--grid-step);
    }
    .viewport.grabbing{cursor:grabbing;}

    .world{
      position:relative;width:var(--world-size);height:var(--world-size);
      box-shadow: inset 0 0 0 1px rgba(127,179,255,0.15);
      background-image:
        radial-gradient(circle at center, rgba(28,200,183,0.06) 0, rgba(28,200,183,0) 45%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px);
    }

    .point{
      position:absolute; border-radius:50%;
      width: calc(var(--point-r) * 2); height: calc(var(--point-r) * 2);
      margin-left: calc(var(--point-r) * -1); margin-top: calc(var(--point-r) * -1);
      background: radial-gradient(circle at 30% 30%, #fff 0 15%, var(--point) 16% 75%, #0b4d49 76% 100%);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25), 0 6px 18px rgba(0,0,0,0.35), inset 0 0 12px rgba(255,255,255,0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }
    .point.active{
      background: radial-gradient(circle at 30% 30%, #ffeeee 0 12%, var(--point-active) 13% 75%, #661c1d 76% 100%);
      box-shadow: 0 0 0 2px rgba(255,77,79,0.35), 0 8px 22px rgba(255,77,79,0.35), inset 0 0 14px rgba(255,255,255,0.35);
      transform: scale(1.08); z-index:5;
    }

    .overlay{position:fixed;inset:0;pointer-events:none}
    .legend{
      position:fixed;right:16px;top:16px;background:rgba(7,10,16,0.8);
      border:1px solid rgba(127,179,255,0.25);border-radius:12px;padding:12px 14px;
      font-size:14px;color:var(--muted);backdrop-filter:blur(6px)
    }
    .legend b{color:var(--fg)}

    .crosshair{position:fixed;inset:0;pointer-events:none}
    .crosshair::before,.crosshair::after{
      content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      background: linear-gradient(to right,transparent 48%, rgba(127,179,255,0.4) 49%, rgba(127,179,255,0.6) 51%, transparent 52%);
      width:100%;height:1px
    }
    .crosshair::after{
      background: linear-gradient(to bottom,transparent 48%, rgba(127,179,255,0.4) 49%, rgba(127,179,255,0.6) 51%, transparent 52%);
      width:1px;height:100%
    }

    /* Bottom Dynamic Island */
    .island{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%) translateY(16px);
      background:rgba(7,10,16,0.86);
      border:1px solid rgba(127,179,255,0.25);
      border-radius:14px; padding:12px 16px; display:flex; align-items:center; gap:14px;
      color:var(--fg); box-shadow:0 6px 28px rgba(0,0,0,0.35);
      backdrop-filter:blur(8px);
      opacity:0; pointer-events:none; transition:opacity 180ms ease, transform 220ms ease, border-color 200ms ease, box-shadow 200ms ease;
      width:min(820px, calc(100vw - 128px));
      overflow:hidden;
    }
    .island.visible{ opacity:1; transform:translateX(-50%) translateY(0); }
    .island .bg{ position:absolute; inset:18px; background-image:none; background-size:cover; background-position:center; background-repeat:no-repeat; background-blend-mode:overlay; filter: blur(36px) saturate(1.12) brightness(0.92); transform:scale(1.18); opacity:0.9; z-index:0; }
    .island > :not(.bg){ position:relative; z-index:1; }
    .island img{ width:68px; height:68px; border-radius:10px; object-fit:cover; box-shadow:0 2px 10px rgba(0,0,0,0.35); }
    .island .text{ display:flex; flex-direction:column; min-width:0; }
    .island .title{ font-weight:600; line-height:1.15; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .island .subtitle{ color:var(--muted); font-size:12px; margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>
<body>
  <div id="app" class="viewport">
    <div id="world" class="world" aria-label="Scrollable world plane"></div>
  </div>

  <!-- SVG overlay (no yellow arcs anymore) -->
  <svg id="hud" class="overlay" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <!-- Gradient for orbit stroke: from center to orbit center -->
      <linearGradient id="orbitGrad" x1="0" y1="0" x2="0" y2="0" gradientUnits="userSpaceOnUse">
        <stop offset="0%" stop-color="var(--center-stroke)" stop-opacity="1"/>
        <stop offset="100%" stop-color="var(--center-stroke)" stop-opacity="0.55"/>
      </linearGradient>
    </defs>
    <!-- Tidal ring segments -->
    <path id="tideCenter" d="" fill="var(--tide)"  fill-opacity="1" stroke="none"/>
    <path id="tideTarget" d="" fill="var(--tide2)" fill-opacity="0.75" stroke="none"/>

    <!-- Central & target outlines -->
    <circle id="centerDisk" cx="0" cy="0" r="0" fill="var(--center-stroke)" opacity="1"/>
    <circle id="centerCircle" cx="0" cy="0" r="0" fill="none" stroke="var(--center-stroke)" stroke-width="2.5"/>
    <circle id="targetCircle" cx="0" cy="0" r="0" fill="none" stroke="var(--center-stroke)" stroke-width="2.2" opacity="0.9"/>

    <!-- Orbit tide mechanic -->
    <circle id="orbitCircle" cx="0" cy="0" r="0" fill="var(--center-stroke)" fill-opacity="1" stroke="var(--center-stroke)" stroke-width="2" opacity="1"/>
    <!-- Filled area between tangents and two circles -->
    <path id="bridge" d="" fill="var(--center-stroke)" fill-opacity="1" stroke="none"/>
    <line id="tan1" x1="0" y1="0" x2="0" y2="0" stroke="var(--center-stroke)" stroke-width="2" stroke-linecap="round"/>
    <line id="tan2" x1="0" y1="0" x2="0" y2="0" stroke="var(--center-stroke)" stroke-width="2" stroke-linecap="round"/>
  </svg>

  <div class="crosshair"></div>

  <div class="legend">
    <div><b>Closest ID:</b> <span id="closestId">–</span></div>
    <div><b>Distance:</b> <span id="dist">–</span> px</div>
    <div><b>Outer radius:</b> <span id="outer">–</span> px</div>
    <div><b>World center:</b> <span id="wcx">–</span>, <span id="wcy">–</span></div>
  </div>

  <!-- Bottom Dynamic Island -->
  <div id="island" class="island" aria-live="polite" aria-atomic="true">
    <div class="bg"></div>
    <img id="islandImg" alt="" />
    <div class="text">
      <div id="islandTitle" class="title">—</div>
      <div id="islandSubtitle" class="subtitle">—</div>
    </div>
  </div>

  <script>
  (function(){
    // ====== CONFIG ======
    const WORLD_SIZE = 4000;
    const CENTER_R   = 100;
    const CENTER_DISK_R = 16; // central disk radius (px), ~32x32 diameter

    // tide visuals
    const TIDE_WIDTH_MIN = 0.35;  // radians
    const TIDE_WIDTH_MAX = 1.20;  // radians
    const TIDE_MAX       = 120;   // px
    const TIDE_MIN       = 2;     // px
    const TIDE_KC        = 2800;  // central tide scale
    const TIDE_KP        = 1800;  // target tide scale
    const ANIM_MS        = 360;

    // orbit tide mechanic
    const ORBIT_K        = 3800; // scale for orbit radius (visual tuning)
    const ORBIT_MAX      = 200;  // clamp orbit radius

    // point layout
    const POINT_GRID_STEP = 200; // px spacing between points (smaller -> denser)
    const POINT_RADIUS    = 6;   // px radius of each point (smaller -> smaller)
    const POINT_JITTER    = 40;  // px random jitter to avoid perfect lattice

    // ====== PRESET POINTS (generated dense jittered grid) ======
    function generatePoints(){
      const pts = [];
      for (let x = POINT_GRID_STEP/2; x <= WORLD_SIZE - POINT_GRID_STEP/2; x += POINT_GRID_STEP){
        for (let y = POINT_GRID_STEP/2; y <= WORLD_SIZE - POINT_GRID_STEP/2; y += POINT_GRID_STEP){
          const jx = (Math.random()*2 - 1) * POINT_JITTER;
          const jy = (Math.random()*2 - 1) * POINT_JITTER;
          const px = Math.max(20, Math.min(WORLD_SIZE - 20, Math.round(x + jx)));
          const py = Math.max(20, Math.min(WORLD_SIZE - 20, Math.round(y + jy)));
          pts.push({ x: px, y: py, r: POINT_RADIUS });
        }
      }
      return pts;
    }
    const PRESET_POINTS = generatePoints();

    // ====== DOM ======
    const viewport = document.getElementById('app');
    const world    = document.getElementById('world');

    const tideC = document.getElementById('tideCenter');
    const tideT = document.getElementById('tideTarget');

    const centerCircle = document.getElementById('centerCircle');
    const centerDisk   = document.getElementById('centerDisk');
    const targetCircle = document.getElementById('targetCircle');
    const orbitGradEl = document.getElementById('orbitGrad');

    const legendId   = document.getElementById('closestId');
    const legendDist = document.getElementById('dist');
    const legendOuter= document.getElementById('outer');
    const legendWcx  = document.getElementById('wcx');
    const legendWcy  = document.getElementById('wcy');

    // Island DOM
    const island       = document.getElementById('island');
    const islandImg    = document.getElementById('islandImg');
    const islandTitle  = document.getElementById('islandTitle');
    const islandSub    = document.getElementById('islandSubtitle');
    const islandBg     = document.querySelector('#island .bg');

    // ====== Build points ======
    function buildMeta(i, p){
      const moods = [
        'Calm','Bright','Gloomy','Vivid','Misty','Lush','Golden','Crimson','Azure','Silent',
        'Breezy','Cozy','Nocturne','Verdant','Amber','Frosty','Velvet','Radiant','Dusky','Serene'
      ];
      const places = [
        'Harbor','Peak','Valley','Grove','Dunes','Lagoon','Meadow','Pass','Basin','Ridge',
        'Cove','Bluff','Glade','Fjord','Reef','Bay','Hollow','Spring','Falls','Heights'
      ];
      const mood = moods[i % moods.length];
      const place = places[(i * 7) % places.length];
      const title = mood + ' ' + place;
      const subtitle = `#${i} • (${p.x}, ${p.y}) • r=${p.r}`;
      const image = `https://picsum.photos/seed/mood-${i}-${p.x}-${p.y}/160/120`;
      return { title, subtitle, image };
    }

    const points = PRESET_POINTS.map((p,i)=>{
      const el = document.createElement('div');
      el.className = 'point';
      el.style.left = p.x + 'px';
      el.style.top  = p.y + 'px';
      el.style.setProperty('--point-r', p.r + 'px');
      const meta = buildMeta(i, p);
      el.title = `${meta.title} — ${meta.subtitle}`;
      el.dataset.id = String(i);
      world.appendChild(el);
      return {id:i, x:p.x, y:p.y, r:p.r, el, ...meta};
    });

    const PALETTES = [
      ['#4f7cff','#50d5ff','#22cbb8'], // cool blue/teal
      ['#ff8a5b','#ffd166','#f4a261'], // warm sunset
      ['#a78bfa','#7dd3fc','#60a5fa'], // violet to sky
      ['#34d399','#a7f3d0','#22c55e'], // greens
      ['#f472b6','#fb7185','#fca5a5']  // pink-red soft
    ];

    function setIsland(point, captured){
      if (!point){
        island.classList.remove('visible');
        return;
      }
      islandImg.src = point.image;
      islandImg.alt = point.title;
      islandTitle.textContent = point.title;
      islandSub.textContent = point.subtitle;
      const pal = PALETTES[point.id % PALETTES.length];
      const [c1,c2,c3] = pal;
      island.style.setProperty('--i-c1', c1);
      island.style.setProperty('--i-c2', c2);
      island.style.setProperty('--i-c3', c3);
      if (islandBg){
        islandBg.style.backgroundImage = `linear-gradient(120deg, ${c1}, ${c2}, ${c3}), url('${point.image}')`;
      }
      island.classList.add('visible');
      island.classList.toggle('captured', !!captured);
    }

    // ====== Helpers ======
    const TAU = Math.PI * 2;
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const ease  = t => t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;

    const normAngle = a => (a%TAU + TAU)%TAU;
    function lerpAngle(a,b,t){
      a = normAngle(a); b = normAngle(b);
      let d = b - a;
      if (d > Math.PI) d -= TAU;
      if (d < -Math.PI) d += TAU;
      return a + d * t;
    }
    function w2o(x,y){ return { x: x - viewport.scrollLeft, y: y - viewport.scrollTop }; }
    function polar(cx, cy, r, a){ return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) }; }

    function worldCenter(){
      return {
        cx: viewport.scrollLeft + viewport.clientWidth/2,
        cy: viewport.scrollTop  + viewport.clientHeight/2
      };
    }
    function updateCenterCircle(){
      const ccx = viewport.clientWidth/2;
      const ccy = viewport.clientHeight/2;
      centerCircle.setAttribute('cx', ccx);
      centerCircle.setAttribute('cy', ccy);
      centerCircle.setAttribute('r', CENTER_R);
      // center disk (tide origin)
      centerDisk.setAttribute('cx', ccx);
      centerDisk.setAttribute('cy', ccy);
      centerDisk.setAttribute('r', CENTER_DISK_R);
    }
    function closestTo(cx, cy){
      let best=null, bestD2=Infinity;
      for (const p of points){
        const dx = p.x - cx, dy = p.y - cy, d2 = dx*dx + dy*dy;
        if (d2 < bestD2){ bestD2 = d2; best = p; }
      }
      return { p:best, d: Math.sqrt(bestD2) };
    }

    // Build an annular ring-segment (no pointy tip):
    // bounded by radii [rBase, rBase + amp], over angle [ang-W, ang+W]
    function ringLobePath(cx, cy, rBase, amp, ang, W){
      const r1 = rBase;
      const r2 = rBase + amp;

      const a1 = ang - W;
      const a2 = ang + W;

      const P1 = w2o(...Object.values(polar(cx, cy, r1, a1)));
      const P2 = w2o(...Object.values(polar(cx, cy, r2, a1)));
      const P3 = w2o(...Object.values(polar(cx, cy, r2, a2)));
      const P4 = w2o(...Object.values(polar(cx, cy, r1, a2)));

      const large = (2*W > Math.PI) ? 1 : 0;

      return [
        `M ${P1.x.toFixed(2)} ${P1.y.toFixed(2)}`,
        `L ${P2.x.toFixed(2)} ${P2.y.toFixed(2)}`,
        `A ${r2} ${r2} 0 ${large} 1 ${P3.x.toFixed(2)} ${P3.y.toFixed(2)}`,
        `L ${P4.x.toFixed(2)} ${P4.y.toFixed(2)}`,
        `A ${r1} ${r1} 0 ${large} 0 ${P1.x.toFixed(2)} ${P1.y.toFixed(2)}`,
        `Z`
      ].join(' ');
    }

    // ====== Animated params ======
    let activeId = -1;
    let anim = null; // {t0,t1, from:{ang,d,rp}, to:{ang,d,rp}}

    function currentParams(){
      const {cx, cy} = worldCenter();
      const {p, d} = closestTo(cx, cy);
      if (!p) return null;

      const base = { ang: Math.atan2(p.y - cy, p.x - cx), d, rp: p.r };
      if (!anim) return base;

      const now = performance.now();
      const t = clamp((now - anim.t0)/(anim.t1 - anim.t0), 0, 1);
      const s = ease(t);
      return {
        ang: lerpAngle(anim.from.ang, anim.to.ang, s),
        d:   lerp(anim.from.d,   anim.to.d,   s),
        rp:  lerp(anim.from.rp,  anim.to.rp,  s)
      };
    }

    function startAnim(from, to){
      const now = performance.now();
      anim = { t0: now, t1: now + ANIM_MS, from, to };
      requestAnimationFrame(frame);
    }

    // ====== Render loop ======
    let raf = null;
    function schedule(){ if(!raf) raf = requestAnimationFrame(frame); }

    function frame(){
      raf = null;
      updateCenterCircle();

      const {cx, cy} = worldCenter();
      const {p, d} = closestTo(cx, cy);
      if (!p) return;

      // highlight point
      for (const q of points) q.el.classList.toggle('active', q === p);

      // if target changed -> animate
      const angNew = Math.atan2(p.y - cy, p.x - cx);
      if (activeId !== p.id){
        const cur = currentParams() || {ang: angNew, d, rp: p.r};
        startAnim(cur, {ang: angNew, d, rp: p.r});
        activeId = p.id;
        setIsland(p, false);
      }

      const pr = currentParams() || {ang: angNew, d, rp: p.r};

      // reference: target circle (blue)
      const targetOv = w2o(p.x, p.y);
      targetCircle.setAttribute('cx', targetOv.x);
      targetCircle.setAttribute('cy', targetOv.y);
      targetCircle.setAttribute('r', p.r);

      // ORBIT tide mechanic
      // - orbit circle radius ro = 2/3 of center circle (visual size), placed at distance R around center towards point
      // - R = mutual force divided by distance, here approximate force ~ (m1*m2)/d^2 with m ~ r^3
      const ri = CENTER_DISK_R; // central disk for mass
      const rOrbitVisual = Math.max(1, Math.round((CENTER_DISK_R * 1/2))); // smaller orbit circle size

      const dx = p.x - cx, dy = p.y - cy;
      const dSafe = Math.max(1, Math.hypot(dx, dy));
      const m1 = ri*ri*ri;
      const m2 = pr.rp*pr.rp*pr.rp;
      const mutualForce = (m1 * m2) / (dSafe*dSafe);
      const R = dSafe/4; // scaled distance

      const ang = Math.atan2(dy, dx);
      const orbitCenter = { x: cx + Math.cos(ang) * R, y: cy + Math.sin(ang) * R };

      const oc = w2o(orbitCenter.x, orbitCenter.y);
      const ccxView = viewport.clientWidth/2;
      const ccyView = viewport.clientHeight/2;
      const orbitCircleEl = document.getElementById('orbitCircle');
      orbitCircleEl.setAttribute('cx', oc.x);
      orbitCircleEl.setAttribute('cy', oc.y);
      orbitCircleEl.setAttribute('r', rOrbitVisual);
      // Update gradient from center to orbit center
      orbitGradEl.setAttribute('x1', String(ccxView));
      orbitGradEl.setAttribute('y1', String(ccyView));
      orbitGradEl.setAttribute('x2', String(oc.x));
      orbitGradEl.setAttribute('y2', String(oc.y));

      // Compute external tangents between two circles (center disk and orbit circle)
      function setTangents(cx1, cy1, r1, cx2, cy2, r2){
        const dx = cx2 - cx1, dy = cy2 - cy1;
        const dd = Math.hypot(dx, dy);
        if (dd === 0 || dd < Math.abs(r1 - r2)){
          // null-orbit / concentric or one circle inside the other; hide tangents and orbit
          document.getElementById('tan1').setAttribute('x1', '0');
          document.getElementById('tan1').setAttribute('y1', '0');
          document.getElementById('tan1').setAttribute('x2', '0');
          document.getElementById('tan1').setAttribute('y2', '0');
          document.getElementById('tan2').setAttribute('x1', '0');
          document.getElementById('tan2').setAttribute('y1', '0');
          document.getElementById('tan2').setAttribute('x2', '0');
          document.getElementById('tan2').setAttribute('y2', '0');
          document.getElementById('orbitCircle').setAttribute('r', '0');
          return;
        }
        
        // External tangents between two circles (normalized)
        const ux = dx/dd, uy = dy/dd;           // unit vector from C1 to C2
        const vx = -uy, vy = ux;                // perpendicular unit vector
        const rdiff = (r2 - r1)/3;
        const cosT = clamp(rdiff/dd, -1, 1);    // cos(theta)
        const sinT = Math.sqrt(Math.max(0, 1 - cosT*cosT)); // sin(theta)

        // Unit normals from centers to tangent points (two sides)
        const n1x = ux*cosT - vx*sinT, n1y = uy*cosT - vy*sinT;
        const n2x = ux*cosT + vx*sinT, n2y = uy*cosT + vy*sinT;

        // Start the lines slightly inside the central disk to hide edges
        const INSET = 2; // px
        const r1Inset = Math.max(0, r1 - INSET);

        // Tangent points for lines (inset on center), and full-radius points for fill path
        const A1 = w2o(cx1 + r1Inset*n1x, cy1 + r1Inset*n1y);
        const A1full = w2o(cx1 + r1*n1x, cy1 + r1*n1y);
        const B1 = w2o(cx2 + r2*n1x, cy2 + r2*n1y);
        const A2 = w2o(cx1 + r1Inset*n2x, cy1 + r1Inset*n2y);
        const A2full = w2o(cx1 + r1*n2x, cy1 + r1*n2y);
        const B2 = w2o(cx2 + r2*n2x, cy2 + r2*n2y);

        document.getElementById('tan1').setAttribute('x1', A1.x);
        document.getElementById('tan1').setAttribute('y1', A1.y);
        document.getElementById('tan1').setAttribute('x2', B1.x);
        document.getElementById('tan1').setAttribute('y2', B1.y);
        document.getElementById('tan2').setAttribute('x1', A2.x);
        document.getElementById('tan2').setAttribute('y1', A2.y);
        document.getElementById('tan2').setAttribute('x2', B2.x);
        document.getElementById('tan2').setAttribute('y2', B2.y);

        // Build filled bridge path: A1full -> arc(center r1) -> A2full -> line -> B2 -> arc(orbit r2) -> B1 -> close
        const path = [
          `M ${A1full.x.toFixed(2)} ${A1full.y.toFixed(2)}`,
          `A ${r1} ${r1} 0 0 1 ${A2full.x.toFixed(2)} ${A2full.y.toFixed(2)}`,
          `L ${B2.x.toFixed(2)} ${B2.y.toFixed(2)}`,
          `A ${r2} ${r2} 0 0 0 ${B1.x.toFixed(2)} ${B1.y.toFixed(2)}`,
          `Z`
        ].join(' ');
        document.getElementById('bridge').setAttribute('d', path);
      }

      setTangents(cx, cy, CENTER_DISK_R, orbitCenter.x, orbitCenter.y, rOrbitVisual);

      // Legend
      const ro = Math.max(CENTER_DISK_R + 1, pr.d - p.r);
      legendId.textContent = String(p.id);
      legendDist.textContent = d.toFixed(1);
      legendOuter.textContent = ro.toFixed(1);
      legendWcx.textContent = Math.round(cx);
      legendWcy.textContent = Math.round(cy);

      // Dynamic Island capture highlight (when center circle overlaps the point)
      const dxCap = p.x - cx, dyCap = p.y - cy;
      const d2Cap = dxCap*dxCap + dyCap*dyCap;
      const overlapRCap = (CENTER_R + p.r);
      const isCaptured = d2Cap <= overlapRCap * overlapRCap;
      island.classList.toggle('captured', isCaptured);

      // keep anim running
      if (anim){
        const now = performance.now();
        if (now < anim.t1) requestAnimationFrame(frame);
        else anim = null;
      }
    }

    // ====== Init & events ======
    viewport.scrollLeft = (WORLD_SIZE - viewport.clientWidth)/2;
    viewport.scrollTop  = (WORLD_SIZE - viewport.clientHeight)/2;

    viewport.addEventListener('scroll', () => schedule(), {passive:true});
    window.addEventListener('resize', () => { updateCenterCircle(); schedule(); });

    // Drag-to-pan + SNAP ON RELEASE to center the active point
    (function enableDragPan(){
      let dragging=false, sx=0, sy=0, sl=0, st=0, pid=0;

      const clampScroll = () => {
        viewport.scrollLeft = clamp(viewport.scrollLeft, 0, WORLD_SIZE - viewport.clientWidth);
        viewport.scrollTop  = clamp(viewport.scrollTop , 0, WORLD_SIZE - viewport.clientHeight);
      };

      viewport.addEventListener('pointerdown', (e)=>{
        dragging=true; pid=e.pointerId; viewport.setPointerCapture(pid);
        viewport.classList.add('grabbing'); sx=e.clientX; sy=e.clientY; sl=viewport.scrollLeft; st=viewport.scrollTop;
      });

      viewport.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        viewport.scrollLeft = sl - dx;
        viewport.scrollTop  = st - dy;
        clampScroll(); schedule();
      });

      function end(){
        // if (dragging){
          // Snap when the closest point overlaps/intersects the central capture circle
          const {cx, cy} = worldCenter();
          const {p} = closestTo(cx, cy);
          if (p){
            const dx = p.x - cx, dy = p.y - cy;
            const d2 = dx*dx + dy*dy;
            const overlapR = (CENTER_R + p.r);
            if (d2 <= overlapR * overlapR){
              const targetLeft = p.x - viewport.clientWidth/2;
              const targetTop  = p.y - viewport.clientHeight/2;
              viewport.scrollTo({ left: clamp(targetLeft, 0, WORLD_SIZE - viewport.clientWidth),
                                  top:  clamp(targetTop , 0, WORLD_SIZE - viewport.clientHeight),
                                  behavior: 'smooth' });
            }
          }
        // }
        dragging=false; viewport.classList.remove('grabbing');
      }
      viewport.addEventListener('touchend', end);
      viewport.addEventListener('pointerup', end);
      viewport.addEventListener('pointercancel', end);
      viewport.addEventListener('pointerleave', end);
    })();

    // first paint
    updateCenterCircle();
    frame();
  })();
  </script>
</body>
</html>