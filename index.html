<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Scrollable World • Ring-Segment Tides + Snap-to-Center</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --world-size: 4000px;
      --center-r: 80;              /* central circle radius (px) */
      --grid-step: 80px;

      --bg-1:#0b0f14; --fg:#eaf2ff; --muted:#8aa4c1;
      --center-stroke:#7fb3ff;     /* blue outlines */
      --tide:#23d4c0;              /* teal tides */
      --tide2:#22cbb8;             /* second teal (target) */

      --point:#1cc8b7;
      --point-active:#ff4d4f;
    }

    html,body{height:100%;margin:0;background:var(--bg-1);color:var(--fg);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

    .viewport{
      position:relative;height:100%;overflow:auto;overscroll-behavior:contain;cursor:grab;
      scroll-behavior:smooth;
      background:
        linear-gradient(90deg,#0b0f14 0,#0b0f14 calc(var(--grid-step) - 1px),#0b2135 calc(var(--grid-step) - 1px),#0b2135 var(--grid-step)),
        linear-gradient(180deg,#0b0f14 0,#0b0f14 calc(var(--grid-step) - 1px),#0b2135 calc(var(--grid-step) - 1px),#0b2135 var(--grid-step));
      background-size:var(--grid-step) var(--grid-step);
    }
    .viewport.grabbing{cursor:grabbing;}

    .world{
      position:relative;width:var(--world-size);height:var(--world-size);
      box-shadow: inset 0 0 0 1px rgba(127,179,255,0.15);
      background-image:
        radial-gradient(circle at center, rgba(28,200,183,0.06) 0, rgba(28,200,183,0) 45%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px);
    }

    .point{
      position:absolute; border-radius:50%;
      width: calc(var(--point-r) * 2); height: calc(var(--point-r) * 2);
      margin-left: calc(var(--point-r) * -1); margin-top: calc(var(--point-r) * -1);
      background: radial-gradient(circle at 30% 30%, #fff 0 15%, var(--point) 16% 75%, #0b4d49 76% 100%);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25), 0 6px 18px rgba(0,0,0,0.35), inset 0 0 12px rgba(255,255,255,0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }
    .point.active{
      background: radial-gradient(circle at 30% 30%, #ffeeee 0 12%, var(--point-active) 13% 75%, #661c1d 76% 100%);
      box-shadow: 0 0 0 2px rgba(255,77,79,0.35), 0 8px 22px rgba(255,77,79,0.35), inset 0 0 14px rgba(255,255,255,0.35);
      transform: scale(1.08); z-index:5;
    }

    .overlay{position:fixed;inset:0;pointer-events:none}
    .legend{
      position:fixed;right:16px;top:16px;background:rgba(7,10,16,0.8);
      border:1px solid rgba(127,179,255,0.25);border-radius:12px;padding:12px 14px;
      font-size:14px;color:var(--muted);backdrop-filter:blur(6px)
    }
    .legend b{color:var(--fg)}

    .crosshair{position:fixed;inset:0;pointer-events:none}
    .crosshair::before,.crosshair::after{
      content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      background: linear-gradient(to right,transparent 48%, rgba(127,179,255,0.4) 49%, rgba(127,179,255,0.6) 51%, transparent 52%);
      width:100%;height:1px
    }
    .crosshair::after{
      background: linear-gradient(to bottom,transparent 48%, rgba(127,179,255,0.4) 49%, rgba(127,179,255,0.6) 51%, transparent 52%);
      width:1px;height:100%
    }
  </style>
</head>
<body>
  <div id="app" class="viewport">
    <div id="world" class="world" aria-label="Scrollable world plane"></div>
  </div>

  <!-- SVG overlay (no yellow arcs anymore) -->
  <svg id="hud" class="overlay" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
    <!-- Tidal ring segments -->
    <path id="tideCenter" d="" fill="var(--tide)"  fill-opacity="0.9" stroke="none"/>
    <path id="tideTarget" d="" fill="var(--tide2)" fill-opacity="0.75" stroke="none"/>

    <!-- Central & target outlines -->
    <circle id="centerCircle" cx="0" cy="0" r="0" fill="none" stroke="var(--center-stroke)" stroke-width="2.5"/>
    <circle id="targetCircle" cx="0" cy="0" r="0" fill="none" stroke="var(--center-stroke)" stroke-width="2.2" opacity="0.9"/>
  </svg>

  <div class="crosshair"></div>

  <div class="legend">
    <div><b>Closest ID:</b> <span id="closestId">–</span></div>
    <div><b>Distance:</b> <span id="dist">–</span> px</div>
    <div><b>Outer radius:</b> <span id="outer">–</span> px</div>
    <div><b>World center:</b> <span id="wcx">–</span>, <span id="wcy">–</span></div>
  </div>

  <script>
  (function(){
    // ====== CONFIG ======
    const WORLD_SIZE = 4000;
    const CENTER_R   = 80;

    // tide visuals
    const TIDE_WIDTH_MIN = 0.35;  // radians
    const TIDE_WIDTH_MAX = 1.20;  // radians
    const TIDE_MAX       = 120;   // px
    const TIDE_MIN       = 2;     // px
    const TIDE_KC        = 2800;  // central tide scale
    const TIDE_KP        = 1800;  // target tide scale
    const ANIM_MS        = 360;

    // ====== PRESET POINTS ======
    const PRESET_POINTS = [
      {x:  300, y:  320, r: 16}, {x:  640, y:  880, r: 20}, {x:  960, y:  420, r: 14},
      {x: 1200, y:  760, r: 18}, {x:  480, y: 1420, r: 20}, {x:  880, y: 1660, r: 22},
      {x: 1550, y:  520, r: 16}, {x: 1740, y:  980, r: 24}, {x: 2060, y:  740, r: 18},
      {x: 2320, y: 1150, r: 20}, {x: 2600, y:  540, r: 16}, {x: 2820, y:  980, r: 18},
      {x:  400, y: 2280, r: 20}, {x:  880, y: 2140, r: 16}, {x: 1180, y: 2460, r: 22},
      {x: 1600, y: 2200, r: 18}, {x: 1860, y: 1860, r: 20}, {x: 2140, y: 2360, r: 16},
      {x: 2480, y: 2100, r: 22}, {x: 2800, y: 2440, r: 18}, {x: 3180, y: 2240, r: 20},
      {x: 3400, y: 1900, r: 16}, {x: 3560, y: 1500, r: 14}, {x: 3720, y: 1120, r: 18},
      {x:  260, y: 3100, r: 20}, {x:  700, y: 3400, r: 16}, {x: 1100, y: 3200, r: 18},
      {x: 1460, y: 3520, r: 20}, {x: 1900, y: 3320, r: 16}, {x: 2280, y: 3620, r: 22},
      {x: 2660, y: 3300, r: 18}, {x: 2980, y: 3560, r: 20}, {x: 3360, y: 3240, r: 16},
      {x: 3680, y: 3520, r: 18}, {x: 3520, y:  420, r: 22}, {x:  220, y:  600, r: 16}
    ];

    // ====== DOM ======
    const viewport = document.getElementById('app');
    const world    = document.getElementById('world');

    const tideC = document.getElementById('tideCenter');
    const tideT = document.getElementById('tideTarget');

    const centerCircle = document.getElementById('centerCircle');
    const targetCircle = document.getElementById('targetCircle');

    const legendId   = document.getElementById('closestId');
    const legendDist = document.getElementById('dist');
    const legendOuter= document.getElementById('outer');
    const legendWcx  = document.getElementById('wcx');
    const legendWcy  = document.getElementById('wcy');

    // ====== Build points ======
    const points = PRESET_POINTS.map((p,i)=>{
      const el = document.createElement('div');
      el.className = 'point';
      el.style.left = p.x + 'px';
      el.style.top  = p.y + 'px';
      el.style.setProperty('--point-r', p.r + 'px');
      el.title = `Point #${i} (${p.x}, ${p.y}) r=${p.r}`;
      el.dataset.id = String(i);
      world.appendChild(el);
      return {id:i, x:p.x, y:p.y, r:p.r, el};
    });

    // ====== Helpers ======
    const TAU = Math.PI * 2;
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const ease  = t => t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;

    const normAngle = a => (a%TAU + TAU)%TAU;
    function lerpAngle(a,b,t){
      a = normAngle(a); b = normAngle(b);
      let d = b - a;
      if (d > Math.PI) d -= TAU;
      if (d < -Math.PI) d += TAU;
      return a + d * t;
    }
    function w2o(x,y){ return { x: x - viewport.scrollLeft, y: y - viewport.scrollTop }; }
    function polar(cx, cy, r, a){ return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) }; }

    function worldCenter(){
      return {
        cx: viewport.scrollLeft + viewport.clientWidth/2,
        cy: viewport.scrollTop  + viewport.clientHeight/2
      };
    }
    function updateCenterCircle(){
      centerCircle.setAttribute('cx', viewport.clientWidth/2);
      centerCircle.setAttribute('cy', viewport.clientHeight/2);
      centerCircle.setAttribute('r', CENTER_R);
    }
    function closestTo(cx, cy){
      let best=null, bestD2=Infinity;
      for (const p of points){
        const dx = p.x - cx, dy = p.y - cy, d2 = dx*dx + dy*dy;
        if (d2 < bestD2){ bestD2 = d2; best = p; }
      }
      return { p:best, d: Math.sqrt(bestD2) };
    }

    // Build an annular ring-segment (no pointy tip):
    // bounded by radii [rBase, rBase + amp], over angle [ang-W, ang+W]
    function ringLobePath(cx, cy, rBase, amp, ang, W){
      const r1 = rBase;
      const r2 = rBase + amp;

      const a1 = ang - W;
      const a2 = ang + W;

      const P1 = w2o(...Object.values(polar(cx, cy, r1, a1)));
      const P2 = w2o(...Object.values(polar(cx, cy, r2, a1)));
      const P3 = w2o(...Object.values(polar(cx, cy, r2, a2)));
      const P4 = w2o(...Object.values(polar(cx, cy, r1, a2)));

      const large = (2*W > Math.PI) ? 1 : 0;

      return [
        `M ${P1.x.toFixed(2)} ${P1.y.toFixed(2)}`,
        `L ${P2.x.toFixed(2)} ${P2.y.toFixed(2)}`,
        `A ${r2} ${r2} 0 ${large} 1 ${P3.x.toFixed(2)} ${P3.y.toFixed(2)}`,
        `L ${P4.x.toFixed(2)} ${P4.y.toFixed(2)}`,
        `A ${r1} ${r1} 0 ${large} 0 ${P1.x.toFixed(2)} ${P1.y.toFixed(2)}`,
        `Z`
      ].join(' ');
    }

    // ====== Animated params ======
    let activeId = -1;
    let anim = null; // {t0,t1, from:{ang,d,rp}, to:{ang,d,rp}}

    function currentParams(){
      const {cx, cy} = worldCenter();
      const {p, d} = closestTo(cx, cy);
      if (!p) return null;

      const base = { ang: Math.atan2(p.y - cy, p.x - cx), d, rp: p.r };
      if (!anim) return base;

      const now = performance.now();
      const t = clamp((now - anim.t0)/(anim.t1 - anim.t0), 0, 1);
      const s = ease(t);
      return {
        ang: lerpAngle(anim.from.ang, anim.to.ang, s),
        d:   lerp(anim.from.d,   anim.to.d,   s),
        rp:  lerp(anim.from.rp,  anim.to.rp,  s)
      };
    }

    function startAnim(from, to){
      const now = performance.now();
      anim = { t0: now, t1: now + ANIM_MS, from, to };
      requestAnimationFrame(frame);
    }

    // ====== Render loop ======
    let raf = null;
    function schedule(){ if(!raf) raf = requestAnimationFrame(frame); }

    function frame(){
      raf = null;
      updateCenterCircle();

      const {cx, cy} = worldCenter();
      const {p, d} = closestTo(cx, cy);
      if (!p) return;

      // highlight point
      for (const q of points) q.el.classList.toggle('active', q === p);

      // if target changed -> animate
      const angNew = Math.atan2(p.y - cy, p.x - cx);
      if (activeId !== p.id){
        const cur = currentParams() || {ang: angNew, d, rp: p.r};
        startAnim(cur, {ang: angNew, d, rp: p.r});
        activeId = p.id;
      }

      const pr = currentParams() || {ang: angNew, d, rp: p.r};

      // reference: target circle (blue)
      const targetOv = w2o(p.x, p.y);
      targetCircle.setAttribute('cx', targetOv.x);
      targetCircle.setAttribute('cy', targetOv.y);
      targetCircle.setAttribute('r', p.r);

      // TIDE amplitude (same density: m ~ r^3, tidal ~ m / d^3)
      const ri = CENTER_R;
      const m1 = ri*ri*ri;
      const m2 = pr.rp*pr.rp*pr.rp;
      const distSafe = Math.max(pr.d, ri + pr.rp + 1);

      const ampCenter = clamp(TIDE_KC * (m2 / (distSafe*distSafe*distSafe)) * (ri/200), TIDE_MIN, TIDE_MAX);
      const ampTarget = clamp(TIDE_KP * (m1 / (distSafe*distSafe*distSafe)) * (p.r/200),  TIDE_MIN, TIDE_MAX);

      // Width grows with amplitude, clamped:
      const Wc = clamp(TIDE_WIDTH_MIN + 0.004 * ampCenter, TIDE_WIDTH_MIN, TIDE_WIDTH_MAX);
      const Wt = clamp(TIDE_WIDTH_MIN + 0.004 * ampTarget, TIDE_WIDTH_MIN, TIDE_WIDTH_MAX);

      // Build ring segments:
      // - Center tide: base is the central circle (outer boundary = ri+amp), centered at pr.ang
      tideC.setAttribute('d', ringLobePath(cx, cy, ri, ampCenter, pr.ang, Wc));

      // - Target tide: base is the target circle, lobe toward the center (angle + PI)
      tideT.setAttribute('d', ringLobePath(p.x, p.y, p.r, ampTarget, pr.ang + Math.PI, Wt));

      // Legend
      const ro = Math.max(ri + 1, pr.d - p.r);
      legendId.textContent = String(p.id);
      legendDist.textContent = d.toFixed(1);
      legendOuter.textContent = ro.toFixed(1);
      legendWcx.textContent = Math.round(cx);
      legendWcy.textContent = Math.round(cy);

      // keep anim running
      if (anim){
        const now = performance.now();
        if (now < anim.t1) requestAnimationFrame(frame);
        else anim = null;
      }
    }

    // ====== Init & events ======
    viewport.scrollLeft = (WORLD_SIZE - viewport.clientWidth)/2;
    viewport.scrollTop  = (WORLD_SIZE - viewport.clientHeight)/2;

    viewport.addEventListener('scroll', () => schedule(), {passive:true});
    window.addEventListener('resize', () => { updateCenterCircle(); schedule(); });

    // Drag-to-pan + SNAP ON RELEASE to center the active point
    (function enableDragPan(){
      let dragging=false, sx=0, sy=0, sl=0, st=0, pid=0;

      const clampScroll = () => {
        viewport.scrollLeft = clamp(viewport.scrollLeft, 0, WORLD_SIZE - viewport.clientWidth);
        viewport.scrollTop  = clamp(viewport.scrollTop , 0, WORLD_SIZE - viewport.clientHeight);
      };

      viewport.addEventListener('pointerdown', (e)=>{
        dragging=true; pid=e.pointerId; viewport.setPointerCapture(pid);
        viewport.classList.add('grabbing'); sx=e.clientX; sy=e.clientY; sl=viewport.scrollLeft; st=viewport.scrollTop;
      });

      viewport.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        viewport.scrollLeft = sl - dx;
        viewport.scrollTop  = st - dy;
        clampScroll(); schedule();
      });

      function end(){
        if (dragging){
          // Snap the active point to the center after release
          const {cx, cy} = worldCenter();
          const {p} = closestTo(cx, cy);
          if (p){
            const targetLeft = p.x - viewport.clientWidth/2;
            const targetTop  = p.y - viewport.clientHeight/2;
            viewport.scrollTo({ left: clamp(targetLeft, 0, WORLD_SIZE - viewport.clientWidth),
                                top:  clamp(targetTop , 0, WORLD_SIZE - viewport.clientHeight),
                                behavior: 'smooth' });
          }
        }
        dragging=false; viewport.classList.remove('grabbing');
      }
      viewport.addEventListener('pointerup', end);
      viewport.addEventListener('pointercancel', end);
      viewport.addEventListener('pointerleave', end);
    })();

    // first paint
    updateCenterCircle();
    frame();
  })();
  </script>
</body>
</html>