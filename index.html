<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Scrollable World • Curved Sectors + Gravity Tides (No &lt;canvas/&gt;)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --world-size: 4000px;
      --center-r: 80;                /* central circle radius (px) */
      --arc-width: 24;               /* width of yellow arc sectors (px) */
      --grid-step: 80px;

      --bg-1:#0b0f14; --fg:#eaf2ff; --muted:#8aa4c1;
      --center-stroke:#7fb3ff;
      --arc-stroke:#ffc54d;          /* yellow arcs */
      --arc-stroke-2:#ffb02a;        /* second arc subtle variance */
      --tide:#23d4c0;                /* teal tides */
      --point:#1cc8b7;
      --point-active:#ff4d4f;
    }

    html,body{height:100%;margin:0;background:var(--bg-1);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

    .viewport{
      position:relative;height:100%;overflow:auto;overscroll-behavior:contain;cursor:grab;
      background:
        linear-gradient(90deg,#0b0f14 0,#0b0f14 calc(var(--grid-step) - 1px),#0b2135 calc(var(--grid-step) - 1px),#0b2135 var(--grid-step)),
        linear-gradient(180deg,#0b0f14 0,#0b0f14 calc(var(--grid-step) - 1px),#0b2135 calc(var(--grid-step) - 1px),#0b2135 var(--grid-step));
      background-size:var(--grid-step) var(--grid-step);
    }
    .viewport.grabbing{cursor:grabbing;}

    .world{
      position:relative;width:var(--world-size);height:var(--world-size);
      box-shadow: inset 0 0 0 1px rgba(127,179,255,0.15);
      background-image:
        radial-gradient(circle at center, rgba(28,200,183,0.06) 0, rgba(28,200,183,0) 45%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px);
    }

    /* preset points as HTML dots */
    .point{
      position:absolute; border-radius:50%;
      width: calc(var(--point-r) * 2); height: calc(var(--point-r) * 2);
      margin-left: calc(var(--point-r) * -1); margin-top: calc(var(--point-r) * -1);
      background: radial-gradient(circle at 30% 30%, #fff 0 15%, var(--point) 16% 75%, #0b4d49 76% 100%);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25), 0 6px 18px rgba(0,0,0,0.35), inset 0 0 12px rgba(255,255,255,0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }
    .point.active{
      background: radial-gradient(circle at 30% 30%, #ffeeee 0 12%, var(--point-active) 13% 75%, #661c1d 76% 100%);
      box-shadow: 0 0 0 2px rgba(255,77,79,0.35), 0 8px 22px rgba(255,77,79,0.35), inset 0 0 14px rgba(255,255,255,0.35);
      transform: scale(1.08); z-index:5;
    }

    /* fixed overlay HUD */
    .overlay{position:fixed;inset:0;pointer-events:none}
    .legend{
      position:fixed;right:16px;top:16px;background:rgba(7,10,16,0.8);
      border:1px solid rgba(127,179,255,0.25);border-radius:12px;padding:12px 14px;
      font-size:14px;color:var(--muted);backdrop-filter:blur(6px)
    }
    .legend b{color:var(--fg)}

    .crosshair{position:fixed;inset:0;pointer-events:none}
    .crosshair::before,.crosshair::after{
      content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      background: linear-gradient(to right,transparent 48%, rgba(127,179,255,0.4) 49%, rgba(127,179,255,0.6) 51%, transparent 52%);
      width:100%;height:1px
    }
    .crosshair::after{
      background: linear-gradient(to bottom,transparent 48%, rgba(127,179,255,0.4) 49%, rgba(127,179,255,0.6) 51%, transparent 52%);
      width:1px;height:100%
    }
  </style>
</head>
<body>
  <div id="app" class="viewport">
    <div id="world" class="world" aria-label="Scrollable world plane"></div>
  </div>

  <!-- SVG overlay -->
  <svg id="hud" class="overlay" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
    <!-- Curved sector arcs (yellow) -->
    <path id="arc1" d="" fill="none" stroke="var(--arc-stroke)" stroke-width="var(--arc-width)" stroke-linecap="round" />
    <path id="arc2" d="" fill="none" stroke="var(--arc-stroke-2)" stroke-width="var(--arc-width)" stroke-linecap="round" opacity="0.95" />

    <!-- Tidal bulges (teal) -->
    <path id="tideCenter" d="" fill="var(--tide)" fill-opacity="0.9" stroke="none"/>
    <path id="tideTarget" d="" fill="var(--tide)" fill-opacity="0.6" stroke="none"/>

    <!-- Central & target outlines -->
    <circle id="centerCircle" cx="0" cy="0" r="0" fill="none" stroke="var(--center-stroke)" stroke-width="2.5"/>
    <circle id="targetCircle" cx="0" cy="0" r="0" fill="none" stroke="var(--center-stroke)" stroke-width="2.2" opacity="0.8"/>
  </svg>

  <div class="crosshair"></div>

  <div class="legend">
    <div><b>Closest ID:</b> <span id="closestId">–</span></div>
    <div><b>Distance:</b> <span id="dist">–</span> px</div>
    <div><b>Outer radius:</b> <span id="outer">–</span> px</div>
    <div><b>World center:</b> <span id="wcx">–</span>, <span id="wcy">–</span></div>
  </div>

  <script>
  (function(){
    // ====== CONFIG ======
    const WORLD_SIZE = 4000;
    const CENTER_R   = 80;
    const ARC_WIDTH  = 24;          // visual width of yellow arcs
    const CURVE_K    = 1.1;         // arc curvature factor (h = CURVE_K * chordLength)
    const ANIM_MS    = 380;         // duration of snap transition
    const TIDE_KC    = 2800;        // central tide visual scale (tuned)
    const TIDE_KP    = 1800;        // target tide visual scale (tuned)
    const TIDE_MAX   = 120;         // clamp on tidal bulge length
    const TIDE_MIN   = 2;           // tiny floor to keep shape stable

    // ====== PRESET POINTS ======
    const PRESET_POINTS = [
      {x:  300, y:  320, r: 16}, {x:  640, y:  880, r: 20}, {x:  960, y:  420, r: 14},
      {x: 1200, y:  760, r: 18}, {x:  480, y: 1420, r: 20}, {x:  880, y: 1660, r: 22},
      {x: 1550, y:  520, r: 16}, {x: 1740, y:  980, r: 24}, {x: 2060, y:  740, r: 18},
      {x: 2320, y: 1150, r: 20}, {x: 2600, y:  540, r: 16}, {x: 2820, y:  980, r: 18},
      {x:  400, y: 2280, r: 20}, {x:  880, y: 2140, r: 16}, {x: 1180, y: 2460, r: 22},
      {x: 1600, y: 2200, r: 18}, {x: 1860, y: 1860, r: 20}, {x: 2140, y: 2360, r: 16},
      {x: 2480, y: 2100, r: 22}, {x: 2800, y: 2440, r: 18}, {x: 3180, y: 2240, r: 20},
      {x: 3400, y: 1900, r: 16}, {x: 3560, y: 1500, r: 14}, {x: 3720, y: 1120, r: 18},
      {x:  260, y: 3100, r: 20}, {x:  700, y: 3400, r: 16}, {x: 1100, y: 3200, r: 18},
      {x: 1460, y: 3520, r: 20}, {x: 1900, y: 3320, r: 16}, {x: 2280, y: 3620, r: 22},
      {x: 2660, y: 3300, r: 18}, {x: 2980, y: 3560, r: 20}, {x: 3360, y: 3240, r: 16},
      {x: 3680, y: 3520, r: 18}, {x: 3520, y:  420, r: 22}, {x:  220, y:  600, r: 16}
    ];

    // ====== DOM ======
    const viewport = document.getElementById('app');
    const world    = document.getElementById('world');
    const hud      = document.getElementById('hud');

    const arc1     = document.getElementById('arc1');
    const arc2     = document.getElementById('arc2');
    const tideC    = document.getElementById('tideCenter');
    const tideT    = document.getElementById('tideTarget');

    const centerCircle = document.getElementById('centerCircle');
    const targetCircle = document.getElementById('targetCircle');

    const legendId   = document.getElementById('closestId');
    const legendDist = document.getElementById('dist');
    const legendOuter= document.getElementById('outer');
    const legendWcx  = document.getElementById('wcx');
    const legendWcy  = document.getElementById('wcy');

    // ====== Build points ======
    const points = PRESET_POINTS.map((p,i)=>{
      const el = document.createElement('div');
      el.className = 'point';
      el.style.left = p.x + 'px';
      el.style.top  = p.y + 'px';
      el.style.setProperty('--point-r', p.r + 'px');
      el.title = `Point #${i} (${p.x}, ${p.y}) r=${p.r}`;
      el.dataset.id = String(i);
      world.appendChild(el);
      return {id:i, x:p.x, y:p.y, r:p.r, el};
    });

    // ====== Helpers ======
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const TAU   = Math.PI * 2;

    function easeInOutCubic(t){
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
    }
    function normAngle(a){ a = (a % TAU + TAU) % TAU; return a; }
    function lerpAngle(a, b, t){
      a = normAngle(a); b = normAngle(b);
      let d = b - a;
      if (d > Math.PI) d -= TAU;
      if (d < -Math.PI) d += TAU;
      return a + d * t;
    }
    function polar(cx, cy, r, ang){ return {x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang)}; }
    function length(x, y){ return Math.hypot(x, y); }
    function w2o(x, y){ return { x: x - viewport.scrollLeft, y: y - viewport.scrollTop }; }

    function worldCenter(){
      return {
        cx: viewport.scrollLeft + viewport.clientWidth/2,
        cy: viewport.scrollTop  + viewport.clientHeight/2
      };
    }
    function updateCenterCircle(){
      centerCircle.setAttribute('cx', viewport.clientWidth/2);
      centerCircle.setAttribute('cy', viewport.clientHeight/2);
      centerCircle.setAttribute('r', CENTER_R);
    }
    function closestTo(cx, cy){
      let best=null, bestD2=Infinity;
      for (const p of points){
        const dx = p.x - cx, dy = p.y - cy, d2 = dx*dx + dy*dy;
        if (d2 < bestD2){ bestD2 = d2; best = p; }
      }
      return { p:best, d: Math.sqrt(bestD2) };
    }

    // Build arc path between two world points using circle center "C" (world)
    function arcPathThrough(Cx, Cy, R, Sx, Sy, Ex, Ey){
      const Sxo = Sx - viewport.scrollLeft, Syo = Sy - viewport.scrollTop;
      const Exo = Ex - viewport.scrollLeft, Eyo = Ey - viewport.scrollTop;
      const Cxo = Cx - viewport.scrollLeft, Cyo = Cy - viewport.scrollTop;

      const aS = Math.atan2(Syo - Cyo, Sxo - Cxo);
      const aE = Math.atan2(Eyo - Cyo, Exo - Cxo);

      // choose minor arc by default; sweep direction based on sign
      let dAng = aE - aS;
      if (dAng <= -Math.PI) dAng += TAU;
      if (dAng > Math.PI)   dAng -= TAU;

      const sweep = dAng >= 0 ? 1 : 0;
      const large = Math.abs(dAng) > Math.PI ? 1 : 0;

      return `M ${Sxo.toFixed(2)} ${Syo.toFixed(2)} A ${R.toFixed(2)} ${R.toFixed(2)} 0 ${large} ${sweep} ${Exo.toFixed(2)} ${Eyo.toFixed(2)}`;
    }

    // Tidal lobe attached to a circle (world coords)
    function tideLobePath(cx, cy, rBase, ang, amp){
      // width (angle span) grows with amplitude
      const W = clamp(0.35 + 0.004 * amp, 0.35, 1.15); // radians
      const L = clamp(amp, TIDE_MIN, TIDE_MAX);

      const Lw = polar(cx, cy, rBase, ang - W);
      const Rw = polar(cx, cy, rBase, ang + W);
      const Tip = polar(cx, cy, rBase + L, ang);

      // control points push outward to make a rounded bulge
      const C1 = polar(cx, cy, rBase + L*0.85, ang - W*0.35);
      const C2 = polar(cx, cy, rBase + L*0.85, ang + W*0.35);

      const Lwo = w2o(Lw.x, Lw.y);
      const Rwo = w2o(Rw.x, Rw.y);
      const Tipo = w2o(Tip.x, Tip.y);
      const C1o  = w2o(C1.x, C1.y);
      const C2o  = w2o(C2.x, C2.y);

      const arcLarge = (2*W) > Math.PI ? 1 : 0;
      // inner arc back along the base circle (clockwise)
      const centerOv = w2o(cx, cy);

      return [
        `M ${Lwo.x.toFixed(2)} ${Lwo.y.toFixed(2)}`,
        `Q ${C1o.x.toFixed(2)} ${C1o.y.toFixed(2)} ${Tipo.x.toFixed(2)} ${Tipo.y.toFixed(2)}`,
        `Q ${C2o.x.toFixed(2)} ${C2o.y.toFixed(2)} ${Rwo.x.toFixed(2)} ${Rwo.y.toFixed(2)}`,
        `A ${rBase} ${rBase} 0 ${arcLarge} 0 ${Lwo.x.toFixed(2)} ${Lwo.y.toFixed(2)}`,
        `Z`
      ].join(' ');
    }

    // ====== State for animation ======
    let activeId = -1;
    let anim = null; // {t0, t1, from:{ang,d,rp}, to:{ang,d,rp}}

    function startAnim(from, to){
      const now = performance.now();
      anim = { t0: now, t1: now + ANIM_MS, from, to };
      requestAnimationFrame(frame);
    }

    // ====== Render ======
    let raf = null;
    function schedule(){ if(!raf) raf = requestAnimationFrame(frame); }

    function frame(){
      raf = null;
      updateCenterCircle();

      const {cx, cy} = worldCenter();
      const {p, d} = closestTo(cx, cy);
      if (!p) return;

      // Highlight active dot
      for (const q of points) q.el.classList.toggle('active', q === p);

      // If snapping target changed, start an interpolation
      const rpNew = p.r;
      const angNew = Math.atan2(p.y - cy, p.x - cx);
      const dNew = d;

      if (activeId !== p.id){
        const cur = currentParams(); // get current drawing params as "from"
        startAnim(cur ?? {ang: angNew, d: dNew, rp: rpNew}, {ang: angNew, d: dNew, rp: rpNew});
        activeId = p.id;
      }

      // Compute current parameters (possibly interpolated)
      const pr = currentParams() || {ang: angNew, d: dNew, rp: rpNew};

      // Endpoints along IL from inner tangent to near-side tangent of target circle
      const ri = CENTER_R;
      const roRaw = pr.d - pr.rp;
      const ro = Math.max(ri + 1, roRaw);

      const Sw = polar(cx, cy, ri, pr.ang);
      const Ew = polar(cx, cy, ro, pr.ang);

      // Draw target circle (for reference)
      const targetOv = w2o(p.x, p.y);
      targetCircle.setAttribute('cx', targetOv.x);
      targetCircle.setAttribute('cy', targetOv.y);
      targetCircle.setAttribute('r', p.r);

      // ---- Curved sectors (two arcs from S to E on opposite bowed sides) ----
      // chord geometry for arc centers
      const vx = Ew.x - Sw.x, vy = Ew.y - Sw.y;
      const L  = Math.hypot(vx, vy) || 1e-6;
      const mx = (Sw.x + Ew.x)/2, my = (Sw.y + Ew.y)/2;
      // unit normal (rotate chord by +90°)
      const nx = -vy / L, ny = vx / L;

      const h  = CURVE_K * L;                          // how far the big-circle center from chord
      const R  = Math.sqrt((L*0.5)*(L*0.5) + h*h);     // circle radius that passes through S and E

      const C1w = {x: mx + nx*h, y: my + ny*h};
      const C2w = {x: mx - nx*h, y: my - ny*h};

      arc1.setAttribute('d', arcPathThrough(C1w.x, C1w.y, R, Sw.x, Sw.y, Ew.x, Ew.y));
      arc2.setAttribute('d', arcPathThrough(C2w.x, C2w.y, R, Sw.x, Sw.y, Ew.x, Ew.y));

      // ---- Tides (teal) ----
      // Same density -> m ∝ r^3
      const m1 = Math.pow(ri, 3);
      const m2 = Math.pow(pr.rp, 3);
      const dd = Math.max(pr.d, ri + pr.rp + 1); // avoid zero

      const ampCenter = clamp(TIDE_KC * (m2 / Math.pow(dd, 3)) * (ri/200), TIDE_MIN, TIDE_MAX);
      const ampTarget = clamp(TIDE_KP * (m1 / Math.pow(dd, 3)) * (p.r/200), TIDE_MIN, TIDE_MAX);

      // near-side bulge on center, far-side on target
      tideC.setAttribute('d', tideLobePath(cx, cy, ri, pr.ang, ampCenter));
      tideT.setAttribute('d', tideLobePath(p.x, p.y, p.r, pr.ang + Math.PI, ampTarget));

      // ---- Legend ----
      document.getElementById('closestId').textContent = String(p.id);
      document.getElementById('dist').textContent = d.toFixed(1);
      document.getElementById('outer').textContent = (ro).toFixed(1);
      document.getElementById('wcx').textContent = Math.round(cx);
      document.getElementById('wcy').textContent = Math.round(cy);

      // keep animation running until finished
      if (anim){
        const now = performance.now();
        if (now < anim.t1) requestAnimationFrame(frame);
        else anim = null;
      }
    }

    // Compute parameters used for drawing right now (with interpolation if active)
    function currentParams(){
      const {cx, cy} = worldCenter();
      let {p, d} = closestTo(cx, cy);
      if (!p) return null;

      const angCur = Math.atan2(p.y - cy, p.x - cx);
      const rpCur  = p.r;
      const dCur   = d;

      if (!anim) return { ang: angCur, d: dCur, rp: rpCur };

      const now = performance.now();
      const t = clamp((now - anim.t0) / (anim.t1 - anim.t0), 0, 1);
      const s = easeInOutCubic(t);

      return {
        ang: lerpAngle(anim.from.ang, anim.to.ang, s),
        d:   lerp(anim.from.d,   anim.to.d,   s),
        rp:  lerp(anim.from.rp,  anim.to.rp,  s)
      };
    }

    // ====== Init scroll near center ======
    viewport.scrollLeft = (WORLD_SIZE - viewport.clientWidth)/2;
    viewport.scrollTop  = (WORLD_SIZE - viewport.clientHeight)/2;

    // Event listeners
    viewport.addEventListener('scroll', () => schedule(), {passive:true});
    window.addEventListener('resize', () => { updateCenterCircle(); schedule(); });

    // Optional drag-to-pan
    (function enableDragPan(){
      let dragging=false, sx=0, sy=0, sl=0, st=0, pid=0;
      const clampScroll = () => {
        viewport.scrollLeft = clamp(viewport.scrollLeft, 0, WORLD_SIZE - viewport.clientWidth);
        viewport.scrollTop  = clamp(viewport.scrollTop , 0, WORLD_SIZE - viewport.clientHeight);
      };
      viewport.addEventListener('pointerdown', (e)=>{
        dragging=true; pid=e.pointerId; viewport.setPointerCapture(pid);
        viewport.classList.add('grabbing'); sx=e.clientX; sy=e.clientY; sl=viewport.scrollLeft; st=viewport.scrollTop;
      });
      viewport.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        viewport.scrollLeft = sl - dx;
        viewport.scrollTop  = st - dy;
        clampScroll(); schedule();
      });
      function end(){ dragging=false; viewport.classList.remove('grabbing'); }
      viewport.addEventListener('pointerup', end);
      viewport.addEventListener('pointercancel', end);
      viewport.addEventListener('pointerleave', end);
    })();

    // First paint
    updateCenterCircle();
    frame();
  })();
  </script>
</body>
</html>